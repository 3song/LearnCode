ActiveMQ学习

1.在网络通讯中，HTTP默认采用同步请求的方式，基于请求响应模式。
2.在客户端与服务器进行通讯时，客户端调用服务接口后，必须等待服务器端完成处理业务请求后，返回结果给客户端才能继续执行，这种情况属于同步调用方式。
3.如果客户端发生网络延迟的情况，客户端有可能会受到影响。
	网络延迟、不可达情况需要处理好服务降级，熔断，服务隔离，限流。

网络通讯采用同步方式有哪些优缺点?
	优点：程序可以及时响应数据给客户端
	缺点：高并发情况下，可能会导致程序阻塞（等待），程序效率较低。

如果订单服务调用会员服务不通的情况下，如何保证数据一致性问题?
传统HTTP方式：需要做好补偿(重试)机制,存放日志表+定时任务执行失败日志，服务器端应该考虑到网络延迟提交数据幂等性问题。
幂等性(重复提交)问题怎么解决：使用全局id区分请求，或者token验证来保证请求唯一性。

MQ自带默认的网络补偿机制以及重试机制，MQ只需要考虑请求幂等性问题。

消息中间件是分布式系统的重要组件，主要解决应用解耦，异步消息，流量削峰等问题，实现高性能，高可用，高伸缩和最终一致性架构。


什么是JMS规范：
JAVA消息服务（JAVA MESSAGE SERVICE）,是一个JAVA平台中面向消息中间件的API角色划分
1.提供者：实现JMS	规范的消息中间件服务器（存放消息的容器）
2.客户端：发送可接收消息的应用程序
3.生产者/发布者：接收并处理消息的客户端（向服务器存放消息）
4.消费者/订阅者：接收并处理消息的客户端（获取消息服务器中的消息）
5.消息：应用程序之间传递的数据内容
6.消息模式：在客户端之间传递消息的方式，JMS中定义了主题和队列	两种模式（点对点模式与发布订阅模式（一对多模式））

1.一个队列里可以存放多个消息
2.消息容器中可以存放多个队列 ****队列原则：先进先出，后进后出

消息概念：生产者与消费者之间传递数据（JSON）

消息发布过程：（属于异步方式）
1.客户端向消息容器存放消息
2.消费者订阅消息容器中的消息
3.将最新消息推送给消费者(当消费者如果启动，在消息容器建立一个长链接，队列中一旦有最新消息（消费者加入一条消息进入队列，此消息将会推送给消费者））（基于长链接模式）

问题? 如果消费者宕机情况下，消息会不会丢失？ 
	不会，因为消息如果没有被消费者消费，消息会一直在队列中（队列是可以缓存消息的）
	队列中存放消息，如果消费者没有及时消费，消息会一直存放在消息队列中

消息中间件可以解决高并发问题（流量削峰问题）。

点对点通讯
生产者发送一条消息到queue（队列），只有一个消费者可以收到消息。
特性：
客户端包括生产者和消费者
队列中的消息只能被一个消息消费者消费，消息消费者可以随时消费队列中的消息。（一对一模式 p2p 点对点模式）

发布订阅
1.发送者发送topic（主题）的消息，只有订阅了topic的订阅者才会收到消息
特性：
客户端包括发布者和订阅者
主题中的消息会被所有订阅者消费
消费者不能消费订阅之前就发送到主题中的消息

发布订阅与点对点模式的区别：
点对点模式 只能保证一个消费者进行消费（一对一）
发布订阅： 只要集群服务订阅该主题就都会收到该主题的消息（一对多）

消息队列就是消息中间件 （不对）

消息指的是生产者与消费者传递数据
消息队列中存放的是消息集合

消息中间件：包含消息队列和发布订阅（主题概念）。

场景说明：用户下单后，订单系统需要通知库存系统，传统的做法是，订单系统直接调用库存系统的接口。

缺点：假如库存系统无法访问，则订单减库存将失败，从而导致订单失败，订单系统和库存系统高度耦合，牵一发而动全身。

耗时时间接口，统一采用MQ推送，不建议采用同步的方式。

流量削峰也是消息队列常用场景，一般在秒杀团抢活动中应用广泛。
应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用宕机，为解决这个问题，一般需要在应用前端加入消息队列。
	秒杀活动注意事项：
	1.需要控制活动的人数
	2.可以缓解短时间内高流量压垮应用。

用户的请求，服务器接收后，首先写入消息队列，如消息队列超过最大数量，则直接抛弃用户请求跳转到错误页面。
秒杀业务根据消息队列中的请求信息，再做后续处理。 秒杀业务全部都在MQ中处理。
秒杀业务如何实现：
核心是使用Redis （由于Redis线程安全，可以保证请求的唯一性） + MQ （MQ可以缓存异步消息） + 服务保护机制（服务降级、隔离、熔断机制）+ 服务限流 + 图形验证码（防止重复调用接口）+ Token  ****

为什么用户注册时，发送邮件以及短信采用mq比较好。
1.提高程序运行效率（用户体验）
2.消费者如果发送短信或邮件失败的情况下，MQ自带重试和补偿机制。


当启动多个消费者时，消费者消费消息采用轮询方式。
点对点方式中，消费者集群默认采用均摊方式（轮询）。
发布订阅模式，需要先订阅消息，才能获取消息（实时模式）（分组模式）。


在JMS 通讯模式

消息队列：点对点模式 queue 如果消费者集群的话，均摊进行消费（均摊消费，或者叫轮询）

发布订阅：一对多 主题topic 如果消费者是一个集群的话，每个消费者都会消费

JMS 默认是自动签收消息 消费者获取到消息时，不管消费者对该消息处理业务逻辑是否成功，都会默认为已经消费。
第二种是手动签收模式，消息中间件将消息推送给消费者，消费者接收到消息之后，必须手动发送命令告诉消息中间件已经消费成功。 
第三种是以事务签收或发送消息。 消费者和生产者都必须commit提交该消息。
手动签收保证消息可靠性比较方便，但事务更加安全，因为事务两边都要提交消息。


auto_acknowledge：
消费者接收到消息后，立即自动向MQ发送确认消息。 可以保证数据一致性

dups_ok_acknowledge
一条消息可以被多次消费，为了确保“一次且仅仅一次发送语义”。影响MQ性能。

client_acknowledge
client端确认模式，手动确认消息已消费。 有可能造成消息堵塞

如何解决mq数据一致性问题：

我在生产中的解决办法是在：利用event表，redis实现分布式事务锁，实现幂等消费。

当消费者接受到消息后，按如下步骤处理：

	先查询event中的消息状态，如果消息存在且未处理，继续往下，若已处理直接返回。
	利用redis，加锁，可以使用redission框架，也可以利用String类型的并设置失效时间的简单方式实现不可重入的锁，个人推荐推荐redission，但是我公司使用的是String类型的并设置失效时间的简单方式。
	加锁成功后，再查询event中的消息状态，如果消息存在且未处理，继续往下，若已处理直接返回。
	消费者处理自己的业务
	更新event表中的状态为已处理
	解锁操作


多线程如何实现同步？线程安全问题。
什么是线程安全问题？
	当多个线程共享一个全局变量（多个人员操作同一张表的同一条数据），做写的操作时，可能会收到其他线程的干扰，导致数据出现问题（数据不一致），这种现象叫做线程安全问题。
	注意：
	1.做读操作的时候，不需要考虑线程安全问题。
	2.多个线程共享一个局部变量时，不需要考虑线程安全问题，局部变量：变量定义在run方法中
	例子: 抢票时：可能会出现 两个线程同时操作某一张票
线程之间如何同步（保证数据的原子性（一致性））
1.使用 Synchroized 自动锁********
2.lock 锁---jdk 1.5 并发包内的  手动锁

线程锁实现方式：
1.在方法内加入 synchronized代码块。 synchronized(object){//需要同步的代码}   
	---参数可以是任何类型   相当于密码。
2.在方法前加入 synchronized 修饰符修饰。 （同步函数） private synchronized void test(){//需要同步的代码}。
	---同步函数使用this锁*****  和同步代码块使用this锁  效果一样，并且可以实现同步，synchronized(this){//需要同步的代码} 
	同步函数：分为静态同步函数（使用static关键字修饰）和非静态同步函数（不使用static关键字修饰）
		-------- 当一个方法被static修饰时会存放在永久区里面，当class被加载时就会初始化   ***********
	区别：同步函数使用this锁
	静态同步函数使用 当前静态方法所在类的class字节码作为锁。 synchronized(TrainThread.class){//需要同步的代码} 
	//项目中不要过多使用静态修饰，gc不会回收静态的资源，浪费jvm内存。



线程锁原理:
有一个线程首先拿到锁，其他线程即使拥有CPU执行权，也需要等待拿到锁的线程释放资源（执行完毕），才能继续获取线程锁。（线程锁会有锁的竞争）
锁如果已经被释放，其他线程才开始获取线程锁，进入到 Synchroized 代码块中去。
锁是在什么时候释放？代码执行完毕或者程序出现异常时，锁就会被释放。


什么时候需要使用线程锁：
	考虑到真正产生共享同一全局变量的时候。
Synchroized 使用条件：
1.必须有两个或两个以上线程。如果只有一个线程的话，需要判断锁，程序效率降低，而且没用
2.多个线程同步，必须使用同一个对象锁。
3.保证只有一个线程执行，其他的线程必须等待之前的线程执行完成。
好处：
可以解决线程安全问题。
缺点：
1.效率非常低。多个线程需要判断锁，较为消耗资源，抢锁需要消耗资源。
2.如果线程锁一直不释放，会造成死锁问题。
线程安全问题的解决思路：多个线程不要同时操作同一个全局变量做写的操作。

