数据库连接池怎么实现

什么是缓存?
缓存应用在什么地方：
   客户端：
      浏览器访问图片
   网络缓存:
      CDN内容分发
      代理服务器缓存（Nginx）
   服务器缓存：
      数据库缓存
缓存作用：目的是减轻服务器的压力，减少网络传输请求。
   如果一旦请求到服务器端之后，那么之后再本地也会缓存一份，再次访问时，请求数据会直接从缓存获取，直接访问业务逻辑，不会重新访问数据库，大大提高了响应速度。
缓存框架分类：
   单点缓存框架（Jvm内置缓存）：
      ehcache：纯java缓存框架，在单个jvm中的缓存框架
   分布式缓存框架：
      redis、memchache


1.Jvm内置缓存
   mybatis,Hibernate 二级缓存 是 SqlFactory会话工厂缓存
   Mybatis 二级缓存机制使用oscache（默认，可集成ehcache）
   Mybatis 二级缓存机制使用ehcache（默认，可集成oscache）
   oscache 与 ehcache ----都是jvm内置缓存，缓存值存放在Jvm缓存中
   session实现方法：（大致）
   class CacheUtils(){
   		public static Map map=new HashMap();
   		public void add(String key,String value){
   			map.put(key,value);
   		}
   		public void get(String key){
   			map.get(key);
   		}
   }
   oscache，ehcache区别
   oscache主要针对数据库访问层
   ehcache 主要针对jsp页面缓存
      ehcache缓存过期策略：
         1.FIFO：先进先出，判断存储时间，离目前时间最远的数据将被删除
         2.LRU：最近最少使用，判断最近使用的时间，离最近使用时间最远的数据将被删除
         3.LFU：最不经常使用，在一段时间内，数据使用次数最少的，将优先被删除
      什么情况下会导致缓存与DB不同步问题：
      update操作 和 delete操作。
      如何解决缓存与DB不同步问题：
         1.重启服务：一般情况下，一般生产环境下，不能随意更改数据库值。
         2.执行update操作时增加主动通知
            先修改，修改成功后，再清除缓存。修改失败时，定时job检查缓存，不同步时清除

   Jvm缓存缺点：
   1.容易内存溢出  ----------------不会容器有大小限制
   2.没有持久化机制（jvm宕掉即失效）--------------------ehcache可配置持久化机制
   3.线程安全问题
   4.多服务器间共享数据
NOSQL(非关系型数据库)：Redis ，MongoDB，memcacha （主要特征将数据存在数据库中）

如何在SpringBoot中使用内置缓存：
1.导包
2.新建ehcache.xml
3.在dao层 加入 @CacheConfig(cacheNames = "baseCache")   cacheNames是在ehcache.xml中定义的<cache name="baseCache"
4.在启动类加入  @EnableCaching//开启缓存
注意点：
jvm重启之后，缓存就会消失（重启项目）
cacheManager.getCache("baseCache").clear(); 使用此方法清理缓存
****注意：解决数据库与缓存值不一致直接清空缓存，再同步数据库中的值，缓存到redis

什么是NOSQL数据库
NOSQL数据库也叫做非关系型数据库
关系型数据库（mysql，oracle，sqlserver）特征：可持久化，有主外键关系，使用sql语句查询，存放在硬盘中
非关系型数据库----缓存数据库，值存放在内存中----java内置缓存
redis ---必须学会 基本数据类型，redis持久化，redis高可用
mongodb ---存储格式为json格式。
membase ---不能做持久化（不能持久化，就是不能高可用）
hasebase ---主要用于大数据
非关系型数据库特征：
1.存储在内存中
2.值以key，value存放
3.分布式情况下多服务器共享数据
4.效率比关系型数据库高
5.数据容易丢失（redis有主从复制（数据备份），可持久化）
redis重点
1.哨兵机制
2.主从复制
3.读写分离
4.redis集群搭建

什么是redis：
非关系型数据库，主要作为缓存数据库使用，redis是单线程。
为什么要用redis？
使用redis能减轻数据库访问压力？因为数据库是IO操作，redis是内存操作，查询内存比查询数据库效率要高。
redis应用场景：
   1.token生成（令牌生成）
   2.短信验证码（临时，有效期）
   3.热点数据（使用redis减轻数据库访问压力）
   4.发布订阅
   5.分布式锁
   6.网站计数器（因为redis是单线程，在高并发情况下，保证全局count的唯一性）
redis可以设置有效期-不设置可能会溢出
redis基本数据类型：
1.String类型
2.Set
3.ZSet
4.hasMap
5.List
排序
Set 无序，不重复
zSet 可排序 ，不重复

**Redis怎样存放对象：使用String类型存放json格式
Java操作Redis数据库（使用Jedis）见示例代码

思考题：Redis实现分布式锁：通过redis存放值，难点在怎样释放锁资源


Redis 高可用机制包括：redis怎么做集群?
1.主从复制，为了保证每一台服务器的数据同步（读写分离，备份，高可用，宕机容错机制，集群(核心是主从复制)）
redis怎么实现主从复制？
Redis实现主从复制，只需要修改配置文件
redis主从复制   分为主和从的角色（master）（slave）
主服务器做读写操作， 从服务器只提供数据，不提供写的权限，实现了备份数据，同时提高了性能
2.哨兵机制---高可用，监听服务器
3.Redis持久化机制（数据的恢复，高可用）
通过RDB存储方式和AOF存储方式 优缺点？
   RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。
   触发RDB快照
      1 在指定的时间间隔内，执行指定次数的写操作
      2 执行save（阻塞， 只管保存快照，其他的等待） 或者是bgsave （异步）命令
      3 执行flushall 命令，清空数据库所有数据，意义不大。
      4 执行shutdown 命令，保证服务器正常关闭且不丢失任何数据，意义...也不大。

      通过RDB文件恢复数据
      将dump.rdb 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。在实际开发中，一般会考虑到物理机硬盘损坏情况，选择备份dump.rdb 。可以从下面的操作演示中可以体会到。
      RDB 的优缺点
      优点：
      1 适合大规模的数据恢复。
      2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。
      缺点：
      1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。
      2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。
      所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。
   AOF ：Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。
      触发AOF快照
         根据配置文件触发，可以是每次执行触发，可以是每秒触发，可以不同步。
         根据AOF文件恢复数据
         正常情况下，将appendonly.aof 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。但在实际开发中，可能因为某些原因导致appendonly.aof 文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof --fix appendonly.aof 进行修复 。从下面的操作演示中体会。
         AOF的重写机制
         前面也说到了，AOF的工作原理是将写操作追加到文件中，文件的冗余内容会越来越多。所以聪明的 Redis 新增了重写机制。当AOF文件的大小超过所设定的阈值时，Redis就会对AOF文件的内容压缩。
         重写的原理：Redis 会fork出一条新进程，读取内存中的数据，并重新写到一个临时文件中。并没有读取旧文件（你都那么大了，我还去读你？？？ o(ﾟДﾟ)っ傻啊！）。最后替换旧的aof文件。
         触发机制：当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。这里的“一倍”和“64M” 可以通过配置文件修改。
         AOF 的优缺点
         优点：数据的完整性和一致性更高
         缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。
Redis是否存在事务（存在）
发布订阅（一般用消息中间件）
缓存雪崩，击穿（架构知识）


keepalived可以重启mysql，nginx，redis
keepalived+哨兵机制才是完整的高可用

集群模式和哨兵模式的区别:
哨兵模式监控权交给了哨兵系统，集群模式中是工作节点自己做监控
哨兵模式发起选举是选举一个leader哨兵节点来处理故障转移，集群模式是在从节点中选举一个新的主节点，来处理故障的转移

EhCache 本地缓存
Redis 分布式缓存可以共享
一级缓存（redis）二级缓存（EhCache） 目的是redis挂了之后，ehcache可以继续使用
一级缓存（EhCache）二级缓存（redis） 先走本地缓存，如果没有本地缓存，会连接redis缓存走网络，提高程序效率

Redis和数据库区别
相同点：都需要网络连接
不同点：存放介质，Redis存放在内存中，数据库存放在硬盘中
从效率来说：数据库需要做IO操作，性能比直接操作内存效率低

Ehcache需要走网络访问么
不需要，直接从本地内存获取
会不会产生Ehcache内存溢出
不会，因为Ehcache有容器大小限制，可以持久化到硬盘上
目的是减轻redis访问压力，也可以提高访问速度

Redis雪崩效应
   在高并发情况下，如果Redis服务突然宕机，那么大量请求会直接访问数据库，导致整个服务不可用。
Redis雪崩效应解决方案
   1.分布式锁（本地锁）
   2.使用消息中间件方式，缓存查询数据请求，解决并发
   3.一级缓存、二级缓存（Ehcache+redis）
   4.均摊分配redis key 的失效时间

Redis缓存穿透原因：
   客户端随机产生不同的key，在缓存中没有该数据，数据库中也没有该数据，这样可能会导致客户端一直产生jdbc请求连接。
      1.使用网关判断客户端传入key的规则，如果不符合数据库查询规则，则直接返回为空。
      2.如果使用的key数据库查询不到结果，直接在redis中存一份null的结果并返回客户端。