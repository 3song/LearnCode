SpringCloud
为什么要使用SpringCloud?
	因为SpringCloud目前来说，是一套比较完整的微服务解决方案框架。
	不像其他RPC远程调用框架，只是解决了某个微服务中的问题，可以把SpringCloud理解为一条龙的微服务解决方案。（微服务全家桶--SpringCloud比较完善）
	微服务中：
	分布式配置中心
	分布式锁
	分布式跟踪
	分布式服务治理
	分布式任务调度平台
	--------------------------------
	如果学习其他微服务框架，是需要整合其他框架帮助解决微服务问题。
StringCould重要：
	1.服务注册与发现
	2.RPC远程调用框架 核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）。
		什么是服务治理？
		在传统的RPC远程调用框架中，管理每个服务与服务之间的依赖关系比较复杂
SpringCloud五大组件：背下来
	Eureka：服务注册于发现。
	Feign：基于动态代理机制，根据注解和选择的机器，拼接请求 url 地址，发起请求。
	Ribbon：实现负载均衡，从一个服务的多台机器中选择一台。
	Hystrix：提供线程池，不同的服务走不同的线程池，实现了不同服务调用的隔离，避免了服务雪崩的问题。
	Zuul：网关管理，由 Zuul 网关转发请求给对应的服务。
SpringCloud Eureka运行过程
当消费者服务启动时，会把当前服务信息注册到注册中心上


SpringCloud Eureka自我保护机制
	分为两种角色：EurekaClient(注册客户端),EurekaServer(注册中心服务端)
	会员服务属于Client端
	1.为什么会产生Eureka自我保护机制?
	为了防止EurekaClient可以正常运行，但是与EurekaServer网络不通的情况下EurekaServer一段时间内不会将EurekaClient服务剔除。
	默认情况下，EurekaClient端定时向EurekaServer端发送心跳包。如果EurekaServer端在一定时间内没有收到EurekaClient端发送的心跳包，便会直接总服务注册列表中剔除该服务（默认是90s内）。但是在短时间内丢失了大量的服务实例心跳，这时候EurekaServer端会开启自我保护机制，不会去剔除该服务。
	2.为什么Eureka不会剔除该服务？（原理）
	为了防止EurekaClient端是可以正常访问，只是EurekaClient端与EurekaServer端网络访问不通。防止误剔除
	在什么环境下才开启自我保护机制?
	在本地环境中，禁止自我保护机制（本地测试可能会重启）
	生产环境
	生产环境下，开启自我保护环境（防止EurekaServer端与EurekaClient有网络延迟）
	修改自我保护机制生效时间时，可能本地缓存服务列表有缓存（缓存30S）
	服务如果真的宕机了：本地调用应该有重试机制，保证接口网络延迟幂等性，做好服务降级。

SpringCloud使用Zookeeper替代Eureka作为注册中心

ZooKeeper是分布式协调工具，可以实现注册中心的功能
节点类型是临时节点

Ribbon本地负载均衡客户端与Nginx服务器端负载均衡区别：
Ribbon本地负载均衡原理：在调用接口的时候,会在eureka注册中心上获取注册信息服务列表，获取列表之后，缓存在jvm本地，然后在本地使用轮询负载均衡策略，完全在本地客户端实现负载均衡，而且这样也可以实现故障转移，当某个服务宕机时，服务调用接口通过Ribbon刷新存活的服务列表。************************

LoadBalancerClient（RibbonLoadBalancerClient是实现类）在初始化的时候（execute方法），会通过ILoadBalance（BaseLoadBalancer是实现类）向Eureka注册中心获取服务注册列表，并且每10s一次向EurekaClient发送“ping”，来判断服务的可用性，如果服务的可用性发生了改变或者服务数量和之前的不一致，则从注册中心更新或者重新拉取。LoadBalancerClient有了这些服务注册列表，就可以根据具体的IRule来进行负载均衡。

Nginx 实现负载均衡 ，客户端所有请求都会交给nginx，然后由nginx转发这些请求，nginx负载均衡是完全在服务器中实现

应用场景：  本地负载均衡器（ribbon）适合于在微服务的rpc远程调用过程中,比如 dubbo ,SpringCloud
nginx 是服务器负载均衡 适合于针对于服务器端负载均衡 比如tomcat ，jetty

feign客户端 调用工具
SpringCloud 中支持两种客户端调用工具
	1.RestTemplte方式调用接口
	2.feign客户端调用工具（较常用）
feign 是一个声明式的Http客户端调用工具，采用接口+注解方式实现，易读性比较强。
实现原理：通过反射机制 先获取区接口上边服务名称，以服务名称去注册中心获取实际服务地址，在获取接口调用方法的requestMapping的路径，获取到路径，通过本地rpc远程调用技术调用接口方法

ribbon：
是一个基于 HTTP 和 TCP 客户端的负载均衡器 
它可以在客户端配置 ribbonServerList（服务端列表），然后默认以轮询请求以策略实现均衡负载，他是使用可以用restTemplate+Ribbon 使用

feign:
Spring Cloud Netflix 的微服务都是以 HTTP 接口的形式暴露的，所以可以用 Apache 的 HttpClient ，而 Feign 是一个使用起来更加方便的 HTTP 客戶端，使用起来就像是调用自身工程的方法，而感觉不到是调用远程方法

事务的4大特性
	分别是原子性、一致性、隔离性、持久性。 *********需要会背
	1、原子性（Atomicity）
	原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

	2、一致性（Consistency）
	一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。举例来说，假设用户A和用户B两者的钱加起来一共是1000，那么不管A和B之间如何转账、转几次账，事务结束后两个用户的钱相加起来应该还得是1000，这就是事务的一致性。

	3、隔离性（Isolation）
	隔离性是当多个用户并发访问数据库时，比如同时操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。
	
	4、持久性（Durability）
	持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务已经正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成。否则的话就会造成我们虽然看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。这是不允许的。


