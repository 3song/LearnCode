高并发全局Id
	高并发情况下生成全局id策略
		1.注意幂等性且全局唯一性
		2.注意安全性，不能被抓包工具获取（加密）
		3.趋势递增性（UUID如何自增）
	订单号命名规则：例如 业务编码+时间戳+机器编号【前4位】+随机四位数+毫秒数。
利用全球UUID生成订单号
	UUID基本概念：
		UUID指在一台机器上生成一串数字，她保证对在同一时空中所有机器都是唯一的
		UUID的组成：当前日期和时间+时钟序列+随机数+全局唯一的IEEE机器识别号
		全局唯一的IEEE机器识别号：如果有网卡，从网卡Mac地址获得，没有网卡以其他方式获得
	优点：
		简单，代码方便
		生成id性能较好，基本不会有性能问题
		全球唯一，在遇到数据迁移，系统数据合并，或者数据库变更的情况下，可以从容应对
	缺点
		没有排序，无法保证趋势递增
		UUID往往是用字符串存储，查询的效率较低
		存储空间比较大，如果是海量数据库，就需要考虑存储量的问题
		数据传输量大
	一般UUID在生成Token领域使用较多
基于数据库自增方式
实现思路：利用数据库自增或者序列号方式生成订单号
		优点：
			1.简单，代码方便，性能可以接受
			2.数字id天然排序，对分页或者需要排序的结果很有帮助
		缺点：
			1.不同的数据库语法和实现方法不同，做数据库迁移时可能需要做处理
			2.在性能达不到要求的情况下，比较难于扩展
			3.在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成id，有单点故障的风险
			4.分表分库会很麻烦
	数据库集群如何考虑数据库自增唯一性
		读写分离（不推荐）
		在数据库集群环境下，默认自增方式存在问题，因为都是从1开始自增，可能会存在重复，所以应该根据数据库集群节点数量来设置自增步长的不同。
			假如有4台mysql数据库节点
				节点1 初始值为1 步长为1：id为1 3 5 7 9
				节点2 初始值为2 步长为2：id为2 4 6 8 10
			缺点：在最开始设置好每台节点自增步长，确定好了Mysql集群数量之后，无法扩展新的Mysql，不然步长的生成方式可能发生变化。如果想要提高扩展性，最好使用UUID作为主键
基于Redis生成全局id策略
	因为Redis是单线程，天生保证原子性，所以可以使用Redis的原子操作 INCR和INCRBY 来实现生成id
	RedisAtomicLong、RedisAtomicDouble、RedisAtomicInteger 中的incrementAndGet() 来实现id自增
	incrementAndGet	作用是自增id 初始值从1开始 默认每次调用自增1（步长为1）
	String.format("%1$05d", RedisAtomicLong.incrementAndGet()); 作用是5位数字补0***
	优点
		不依赖数据库，灵活方便，可以使用Redis的原子操作INCR和INCRBY 来实现id自增
		数字id天然排序，对分页或者需要排序的结果很有帮助
	缺点
		如果系统中没有redis，还需要引入新的系统组件，增加系统复杂度
		需要编码和配置的工作量增大
	注意：在Redis集群中，同样和Mysql一样根据Redis集群节点数量来设置自增步长的不同，同时Key最好设置有效期（一般为24小时）
		RedisAtomicLong.set(10)//初始值
		RedisAtomicLong.addAndGet(10)//设置步长 注意步长从0开始  10 表示每次自增11
		由于id生成是通过key值，所以需要考虑失效时间问题，不然数据库会越来越大（一般24小时）
