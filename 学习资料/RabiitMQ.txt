高性能RabiitMQ
	1.为什么要使用MQ	
		高并发削峰
		应用解耦
	2.ActiveMQ的通讯模式
		队列（点对点）和主题（发布订阅）
RabbitMQ 安装 ：首先安装 Erlang环境
	RabbitMQ 端口号为15672
	需要开启可视化插件
		需新建用户并分配对应的VisualHosts（类似Mysql创建用户并指定登录数据库）
RabbitMQ的五种队列形式
	1.简单队列（点对点队列）
		点对点模式（一对一模式）：一个生产者投递给队列，消费者采用自动应答模式，只能允许有一个消费者消费，如果消费者集群的话，会进行均摊消费（缺点：服务器配置不同时不公平）
		队列：先进先出原则，存放消息的集合
		消息：需要投递的数据
	2.工作（公平）队列模式
		队列服务器向消费者发送消息时，消费者采用手动应答模式，必须收到消费者发送的ACK通知结果，队列服务器才会发送下一条消息（哪一台服务器应答更快，哪一个服务器就多消费消息）
	3.发布订阅模式
		生产者向消费者发送消息，生产者必须首先创建交换机。
		交换机的类型有四种：
			1.Direct exchange（直连交换机）
				处理路由键（RoutingKey）。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “abc”，则只有被标记为“abc”的消息才被转发，不会转发abc.def，也不会转发dog.ghi，只会转发abc。
			2.Fanout exchange（扇形交换机）
				不处理路由键（RoutingKey）。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。
			3.Topic exchange（主题交换机）
				将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“ * ”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.*” 只会匹配到“abc.def”。
			4.Headers exchange（头交换机）
		生产者发送消息给所有的消费者，首先生产者发送消息到交换机，再由交换机发送消息到对应的队列，当消费者服务启动时，会绑定指定的交换机，最后消费者进行拉取或队列进行推送消息。
		交换机无法缓存消息，如果消息没有发送到绑定消费队列的交换机，消息就会丢失。
		如果交换机与消费者队列已经绑定，如果不进行解绑的情况下，即使消费者服务器关闭，消费者队列也依然可以收到生产者发送的消息
		// 发布订阅  发送邮件方为生产者 接收邮件（处理业务）方为消费者
	4.路由模式Routing
		生产者发送消息给消费者，只有当消费者设置了和生产者相同的RoutingKey时，消费者才能收到该生产者发来的消息
		如果生产者发送了一条消息，但是没有指定的rouingKey的消费者，那么，消息就会丢失
	5.通配符模式Topics（与ActiveMQ的Topic（发布订阅）不同）
		生产者 RoutingKey 如果设置为log.email   消费者的routingKey 设置为log.* 表示该消费者会接收到所有RoutingKey 为 log开头的RoutingKey 的生产者发来的消息（* 只能匹配log.email 或 log.sms） , 消费者的routingKey 设置为log.# 表示该消费者会收到所有RoutingKey 为 log开头生产者发来的消息包括子节点下的消息
RabbitMQ 应答模式
	自动应答：不在乎消费者对这个消息的处理是否成功，都会通知给队列删除该消息，如果处理消息失败的情况下，需要实现自动补偿。RabbitMQ默认为自动应答
	手动应答：消费者处理完业务，必须手动返回通知（ACK），通知队列服务器是否删除该消息。 

RabbitMQ消息确认机制：
	消费者如何确保消息被成功消费
	通过应答模式，使用手动应答模式发送ACK包返回结果。默认为自动应答模式。
	如果RabbitMQ服务器宕机，消息会消失么？
		RabbitMQ支持消息持久化机制，会把消息持久化进行报错，默认关闭持久化。
		channel.queueDeclare(SMS_QUEUE, false//这个参数为true表示开启持久化, false, false, null);
	消费者如果确保消息被成功投递
RabbitMQ: rabbitmq 的消息确认机制(事务+confirm)
	在 rabbitmq 中我们可以通过持久化数据解决 rabbitmq 服务器异常的数据丢失问题。
	问题：生产者将消息发送出去之后，消息到底有没有到达 rabbitmq 服务器。默认情况下是不知道的。
	两种方式：
		AMQP 实现了事务机制
		Confirm 模式（确认应答模式解决分布式事务问题）
	事务机制
		txSelect：用户将当前的 channel 设置成 transaction 模式
		txCommit：用于提交事务
		txRollback：回滚事务
	缺点：降低了 rabbitmq 的吞吐量。
RabbitMQ 整合SpringBoot 
	默认情况下，模式为自动应答模式，如果消费者程序出现异常的情况下，会自动实现补偿机制（重试机制）**********，队列服务器发送补偿请求
		@RabbitListener(queues = "FANOUT_EMAIL_QUEUE") 注解底层使用AOP拦截，如果程序没有抛出异常，会自动提交事务
		如果AOP拦截到异常信息，则会自动实现补偿机制，一直重试到不抛出异常为止，该消息会一直缓存到Rabbit服务器端存放，信息也不会被消费。
		所以需要修改重试策略（配置文件如下）
		如何实现重试机制： retry:
			spring:
			  rabbitmq:
			    host: 192.168.50.73
			    username: admin
			    password: 211716
			    ##/ 表示所有主机
			    virtual-host: /admin_host
			    listener:
			      simple:
			        retry:
			          ##程序出现异常(默认情况)会自动重试
			          enabled: true
			          ##最大重试次数
			          max-attempts: 5
			          ##重试间隔时间
			          initial-interval: 3000
		超出重试次数后，则丢弃该消息。
RabbitMQ消息重试机制
	情况1：消费者获取消息时，调用第三方接口，但接口暂时无法访问，是否需要重试。（需要）
	情况2：消费者获取消息时，抛出数据转换异常，是否需要重试（不需要），这需要重新发布版本才可解决。
		对于情况2，如果代码抛出异常是需要重新发布版本才能解决的问题，那么不需要重试，重试也无济于事，应该采用日志记录+定时任务Job健康检查+人工进行补偿的方法。
MQ重试机制或者消费者延迟消费可能出现什么问题？
	可能出现幂等性问题（重复消费）怎么解决？
		使用全局MessageID判断消费方使用同一个ID，解决幂等性。
		或者使用业务逻辑的ID（订单ID、UserID）
如何解决消费者幂等性问题
	使用全局MessageID判断消费方使用同一个ID，解决幂等性。
	通过 message.getMessageProperties().getMessageId() 获取 MessageID，获取的 MessageID可以用来判断是否已经被消费者消费过了，如果已经消费则取消再次消费。
	通常怎么判断呢？（缓存至Redis，或纪录日志文件，当下一次重试时，判断日志文件或查找redis）
		比如上方是一个邮件发送的消费者，在做补偿时，假如上一步邮件发送成功了，我们会把该 ID 存至 redis中，下次再调用时，先去 redis 判断是否存在该 ID 了，如果存在表明已经消费过了则直接返回，不再消费，否则消费，然后将记录存至 redis。
RabbitMQ死信队列
	在高并发情况下，生产者发送消息到RabbitMQ队列，如果队列已满的情况下，可能会造成消息丢失，那么可以给邮件消费者绑定一个死信队列，如果队列长度已满，或者消费者拒绝此消息，或者消息过期的情况下，消费者发送的消息会发送到死信队列中去。避免数据丢失。
RabbitMQ解决分布式事务问题原理：
	采用最终一致性原理：（尽量不需要回滚，最好进行补偿）
		1.确保生产者一定要将数据投递到消息服务器中去，如果投递失败，需要手动补偿重新投递。（Confirm 模式重试机制）
		2.MQ消费者必须成功消费生产者发送的消息。如果不能成功消费，需要采用手动应答Ack方式消费消息（注意重试消费消息幂等性问题）
		3.如何保证第一个事务首先执行（如果生产者发送消息成功之后，代码报错，数据回滚怎么办？订单表回滚一条数据，派单表成功创建（消费）数据）需要创建一个补单消费者进行监听订单消费者，每次创建订单时，都去查询一下数据是否创建成功，如果没有创建成功，则重新补单（添加订单消息）
	
RabbitMQ和ActiveMQ 的区别
	RabbitMQ可以新建用户并分配对应的VisualHosts 来区分不同业务,ActiveMQ不能。每个VisualHosts都是不同的，可灵活区分权限和不同的业务逻辑，相互进行隔离，互不影响。

