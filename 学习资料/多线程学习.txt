多线程学习

什么是进程：进程就是正在运行的程序，它是线程的集合。 进程中一定会有一个主线程。
什么是线程：就是正在独立运行的进程的一个执行路径。
什么是多线程？
为了提高程序的效率。
多线程并不能提高宽带速度，而只是提高效率（是效率）
多线程下载，断点续传。

为什么要使用多线程？
使用多线程，可以提高用户程序效率，使用多线程，每个进程不互相影响，因为都在独立的进程运行。
 需要发100条短信，发一条可能要1s 单线程执行可能需要100s 开启10个线程只需要10s。所以可以提高效率。
应用场景 ： 分布式job（同时执行多个任务调度），ajax异步上传。mq

什么是同步? 什么是异步?

代码从上往下顺序执行，就是单线程，在同一时刻只能执行一个方法，并且方法会按顺序执行，这就是同步过程。
异步就是，使用不同线程执行方法，同一时刻可以执行多个方法，而且方法直接互不影响，这就是异步过程。
	面试题：使用继承方式创建线程好，还是Runnable接口创建接口号？
	Runnable接口好，原因
		1.开发都是以面向接口编程，而且接口可以重写多个，易插拔。
		2.JAVA不支持多继承，继承Thread类后，不可继承其他类，降低了类的可用性。

多线程的几种实现方式？
1.继承Thread类 调用Thread类中的start() 。
2.实现Runnable接口的 run方法   并创建Thread对象  调用对象的start() 。
3.使用匿名内部类方式 并调用对象的start() 。
Thread thread = new Thread(new Runnable() {
            public void run() {
                for (int i = 0; i < 30; i++) {
                    System.out.println("使用匿名内部类方式实现多线程 i的值为：" + i);
                }
            }
        });
        thread.start();
4.实现Callable接口,重写call()方法
5.在企业开发中，使用线程池创建线程
6.使用定时器的
/**
 * 定时任务
 *
 * @author <a href="https://blog.csdn.net/king_kgh>Kingh</a>
 * @version 1.0
 * @date 2019/3/18 10:04
 */
public class CreateThreadDemo9_Timer {

    private static final SimpleDateFormat format =
            new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

    public static void main(String[] args) throws Exception {

        // 创建定时器
        Timer timer = new Timer();
---------------------------------实现多线程
        // 提交计划任务
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                System.out.println("定时任务执行了...");
            }
        }, format.parse("2017-10-11 22:00:00"));
    }
}

停止线程stop() 以弃用。 应使用interrupt() 中断线程。
stop()、resume()、suspend()、destory() 以弃用。
为什么弃用stop：

调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。
调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题。
例如，存在一个对象 u 持有 ID 和 NAME 两个字段，假如写入线程在写对象的过程中，只完成了对 ID 的赋值，但没来得及为 NAME 赋值，就被 stop() 导致锁被释放，那么当读取线程得到锁之后再去读取对象 u 的 ID 和 Name 时，就会出现数据不一致的问题。

interrupt() 方法并不像在 for 循环语句中使用 break 语句那样干脆，马上就停止循环。调用 interrupt() 方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。
线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。
-------------------------------------

public boolean Thread.isInterrupted() //判断是否被中断
public static boolean Thread.interrupted() //判断是否被中断，并清除当前中断状态
这两个方法使得当前线程能够感知到是否被中断了（通过检查标志位）。
所以如果希望线程 t 在中断后停止，就必须先判断是否被中断，并为它增加相应的中断处理代码：

@Override
public void run() {
    super.run();
    for(int i = 0; i <= 200000; i++) {
        //判断是否被中断
        if(Thread.currentThread().isInterrupted()){
            //处理中断逻辑
            break;
        }
        System.out.println("i=" + i);
    }
}

--------------------------------

什么是守护线程?
和main函数相关(和主函数相关)
例如：GC线程（java垃圾回收线程）
特征：守护线程和主线程一起销毁，就是守护线程

什么是非守护线程?
特征：和主线程互不影响。
用户线程，是主线程创建的线程（用户自己创建的线程),如果主线程停止掉，不会影响用户线程。
用户线程也叫非守护线程


多线程的几种运行状态。 
1.创建状态
刚刚创建Thread 没有调用start()之前，都是创建状态
2.准备
刚调用start()时，线程需要等待CPU调度完成，准备运行Thread,这是准备状态。
3.运行
CPU 开始执行run方法时，就是运行状态。
4.休眠（阻塞）
运行run()过程中，调用了sleep方法或者wait()时，当前状态从运行状态变为休眠状态，当线程重新开始时，会重新等待CPU调度，回到准备状态，并继续运行状态。
5.停止
run方法执行完毕或者调用stop() ,那么线程到达死亡状态。

join方法作用：
在A线程中，A线程调用了B线程的join方法，A线程必须等待B线程执行完成之后（A必须释放A自己的CPU执行权），在继续执行。 优先级。
join() 需要在start() 方法之后才有效果。join方法 需要写在run方法内 写在外面 表示主线程让其他线程限制性 ****************************

分批发送短信例子: 分页 ，如果达到服务器性能瓶颈 ，会使用线程池去做。 线程池可以缓存线程 单核cpu一般可以开1000个线程
小项目可以以多线程方式实现，大项目不行，需要考虑线程数量的问题，大项目可以用线程池实现，或者使用mq实现。线程方式发送如果发送失败，无法保证数据一致性，mq可以保证数据的一致性

多线程死锁现象：
同步中嵌套同步，无法释放，线程一直处于等待状态，造成死锁。
死锁的产生原因：同步中嵌套同步，互相都不释放锁资源。