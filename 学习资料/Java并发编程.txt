Java并发编程

对于Java并发编程，一般来说有以下的关注点：
	1.线程安全性，正确性。
	2.线程的活跃性(死锁，活锁)
	3.性能
其中线程的安全性问题是首要解决的问题，线程不安全，运行出来的结果和预期不一致，那就连基本要求都没达到了。
保证线程的安全性问题，本质上就是保证线程同步，实际上就是线程之间的通信问题。我们知道，在操作系统中线程通信有以下几种方式：
	1.信号量
	2.信号
	3.管道
	4.共享内存
	5.消息队列
	6.socket
什么是线程安全问题：
	多个线程同时共享同一个全局变量或者静态变量，其他线程可能会对变量的值造成影响，导致数据丢失其原子性（数据不一致，两个线程同时抢最后一张票），这就叫做线程安全问题。

同步的前提：
需要多个线程才需要同步。
2.多个线程如果向实现同步，必须使用同一个锁对象。

多种方法实现同步：

1.代码被synchronized代码块包裹，表示同时只能有一个线程执行该代码块。能够实现同步。两个线程会进行资源竞争，拿到锁的线程才能访问代码。 
synchronize(this){
	//同步代码
}
2.同步函数：方法使用 synchronized修饰 private synchronized void test() 也可以实现同步。 
	同步函数：synchronized方法使用static关键字修饰
	静态同步函数：synchronized方法使用static 关键字修饰 private static synchronized void test()
注意：同步函数默认使用this锁，静态同步函数默认使用当前Class字节码文件（类的class对象）锁**********************

当一个变量被static修饰时，会存放在永久区内，当class加载时就会被初始化，垃圾回收机制也不会清理static资源
使用synchronized 或 Lock锁 都是在当前Jvm同步，多个Jvm同步需要Nginx，集群，CDN加速有关

死锁的产生 ： 同步中嵌套一个同步，都拿到对应的锁资源都不释放。两个线程都在等待对方释放锁资源。


原理：
1. 首先某一个线程拿到锁，其他线程即使拥有Cpu执行权，也会一直阻塞，等待其他线程释放锁资源。
2.锁是在代码执行完毕或程序出现异常时释放
3.前一个线程把拿到的锁释放掉之后，其他线程才重新进行对象锁资源的竞争，重新进入同步过程。 
优点：解决线程安全问题，保证了多个线程操作共享变量的原子性
缺点
锁的资源竞争，导致效率非常低。
保证线程安全，程序效率一定会变低，因为需要其他线程争夺锁资源。
可能造成死锁问题。


Java内存模型：属于多线程可见性：
	什么是java内存模型？（Java Memory Model，简称JMM）
		JMM描述了java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节。
	什么是线程间的可见性？
		一个线程对共享变量值的修改，能够及时的被其他线程看到。
	什么是共享变量？
		如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。
	java内存模型决定了一个线程与另一个线程是否可见。
	主内存（主要存放共享的全局变量）、私有本地内存（本地内存私有变量).
	**************注意：本地内存存放主内存的共享变量副本。（本地内存中的全局变量的值只是副本，线程每次修改本地内存中的全局变量，会刷新主内存，主内存的值才会更新）
Java内存结构：属于jvm内存分配 堆、栈
多线程的三大特性：
1.原子性（保证线程的唯一性，保证线程安全问题）
2.可见性 java内存模型
3.有序性 join()、wait()、notify() 保证线程的顺序（多线程之间通讯）

synchronized实现可见性以及原子性
JMM关于synchronized的两条规定：
	1>线程解锁前（退出synchronized代码块之前），必须把共享变量的最新值刷新到主内存中，也就是说线程退出synchronized代码块值后，主内存中保存的共享变量的值已经是最新的了
	2>线程加锁时（进入synchronized代码块之后），将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁）
	两者结合：线程解锁前对共享变量的修改在下次加锁时对其他线程可见
	根据以上推出线程执行互斥代码的过程：
	1>获得互斥锁（进入synchronized代码块）
	2>清空工作内存
	3>从主内存拷贝变量的最新副本到工作内存
	4>执行代码
	5>将更改后的共享变量的值刷新到主内存
	6>释放互斥锁（退出synchronized代码块）
Volatile关键字：
	valotile作用：内存可见性、禁止指令重排序
	变量用valatile修饰之后，可以保证线程之间可见（线程1修改某一个共享变量的值，会通知给线程2，线程2会刷新主内存获取最新的值），但不保证原子性。
	不保证线程安全

使用原子类实现线程安全问题

线程实现通讯：
什么是多线程之间的通讯?
多个线程对同一个资源（共享资源，全局变量），每个线程对共享资源做的动作不同，操作不同。

线程之间通讯可能会产生安全问题
	多线程操作资源：可能会同时读一串。 重复读取生产数据
	解决办法：生产者线程生产一个，消费者线程立刻消费一个，如果生产者线程没有生产，消费者同时也不能读取。消费者没有消费完成，生产者线程也不能再次生产.
	使用wait()
wait()作用：让当前线程从运行状态变为休眠状态。 原理：使用当前的锁，等待时，就释放锁的资源。
nottify()作用：让当前线程从休眠状态变为运行状态。（唤醒）
注意：在同步中才能使用。并且是同一个对象锁的资源。

wait() 和sleep() 有什么共同点？
wait() 和 sleep()  都可以把线程从运行状态转变为休眠状态。
wait() 和sleep() 有什么区别？
1.wait() 用于同步中，可以释放当前锁的资源给其他线程。sleep() 并不会释放锁的资源。
2.wait() 需要使用nottify() 来使线程从休眠状态变为运行状态，sleep() 只需要时间到期，就可从休眠状态变为运行状态。
3.wait() 在Object 类中，sleep() 在Thread 类中。

Lock锁：
synchronized 上锁开始是从 synchronized代码块第一行开始上锁 synchronized代码块最后一行释放锁的资源
synchronized锁，是自动锁，自动上锁，自动释放锁资源
synchronized 缺点:效率低、扩展性差、无法自定义锁
JDK1.5 开始 Lock锁位于并发包中，保证线程安全问题。
Lock 与 synchronized 区别：
Lock锁是手动开启上锁，报错时也必须手动释放锁，灵活性强，可扩展性好。synchronized 报错时自动释放锁

Lock lock=new ReentrantLock(); //重入锁   
Lock 分为 重入锁、自旋锁、读写锁



jdk 1.5之后，产生了很多的并发包
HasTable线程虽然安全，但是效率非常低，因为多线程操作hastable，会产生锁的资源竞争。

于是发明了一种新的并发包ConcurrentHasMap
ConcurrentHasMap 使用了分段锁，最高分成16段锁，相当于ConcurrentHasMap 存储了16个HasTable集合，每个线程在操作ConcurrentHasMap时大多数情况下并没有用同一把锁，降低了锁的资源竞争，提高了效率。

和HashTable的区别：
ConcurrentHashMap 是一个并发散列映射表，它允许完全并发的读取，并且支持给定数量的并发更新。
而HashTable和同步包装器包装的 HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。

CountDownLatch 叫做计数器
	countDown() 计数器减一
	await() 导致当前线程等到锁存器计数到零，除非线程是 interrupted 停止状态。 
CyclicBarrier 计数器 当线程执行一定次数时，并行执行
	await() 在所有线程执行完成之后，才执行 await()后面的方法

Semaphore 信号量 ：semaphore.acquire(N); //此方法会把信号量减N 信号量小于0时（达到线程最大限度时） 其他线程若再次调用其余的线程在此等待，直到其他线程释放资源semaphore.release()，才能继续使用。

private Semaphore semaphore = new Semaphore(20);
semaphore.acquire(5);
//省略代码
semaphore.release(5);

在代码中一共有10个许可，每次执行semaphore.acquire（5）；代码时耗费掉5个，所以20/5=4，说明同一时间只有4个线程允许执行acquire（）和release（）之间的代码。

所有的队列都实现了Queue 接口
队列的原则：先进先出，后进后出

并发队列分为有界和无界。
	有界的意思是：有队列长度限制
	无界的意思：不限制队列长度。可以无限制存储。
		ConcurrentLinkedQueue队列
并发队列分为阻塞队列与非阻塞队列
	阻塞队列（有界队列）：队列长度有限制，如果继续存储数据，会进行阻塞，等待消费者消费数据。当生产者写入满的时候，就会阻塞，当队列为空的时候，消费者也会等待生产者写入。
	BlockingQueue，
	无阻塞队列：（无界队列）
pool和peek方法  都是取第一个存储值，pool是取一个删一个，peek不删除数据，只取出第一个
offer 和 add 都是在队列中添加元素 在无界队列 ConcurrentLinkedQueue 中是无区别的，在有界队列中 ，offer 可以设置阻塞时间，而add 不可以设置阻塞时间。


线程池：

数据连接池：主要管理jdbc连接优化管理
线程池：经常创建、启动、销毁一个线程是非常消耗时间的。所以应使用线程池进行管理、复用线程。可以提高程序效率。
线程池的优点：
1.降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的系统资源消耗。
2.提高响应速度，当任务到达时，任务不需要等到线程创建就可以执行。
3.提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程可以进行统一分配、调优和监控。使用了队列的概念。
线程池的实现原理：
java中使用线程池核心是走了ThreadPollExecutor构造函数。
	Executor 封装好了4种创建线程池的方式。***********************
	1.new FixedThreadPool() 创建一个定长线程池，可以控制线程最大的并发数量，超出的线程会在队列中进行等待。
	2.new 创建一个可缓存线程池，如果线程长度超过处理需要，可灵活回收空闲线程，若无可回收线程，则新建一个线程。
	3.new 创建一个定长线程池，支持定时和周期性任务执行。
	4.new 创建一个单线程化的线程池，它只会用唯一的线程执行任务，保证所有的任务按照指定顺序（FIFO，LIFO，优先级）来执行。
线程池：谈到线程池的优点
线程池的创建方式：都是通过 ThreadPollExecutor构造函数创建。
ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory)
	参数说明：
		1. corePoolSize， 核心池大小 （初始化线程池） 用户传的线程池大小
		2. maximumPoolSize 线程池大小 （最大线程池）系统定义的值：Integer.MAX_VALUE
			区别：核心线程池是初始化时线程池大小，线程池大小是线程池最大数量。
		3. keepAliveTime 任务超时终止时间
		4. 定义超时时间 TimeUnit unit
		5.BlockingQueue<Runnable> workQueue 如果用户提交了一个线程 没有超出了初始化线程池大小，则正常创建线程，如果超出初始化线程池大小，则放入workQueue缓存队列中阻塞，如果workQueue缓存队列中已满，则会转移到最大线程池中去。 
			所以：一个线程池中实际上含有两个线程池：一个是核心线程池，一个是最大线程池。 可缓存线程池初始化的大小为零，是只使用最大线程池大小。
线程池配置多少合适：
	CPU密集型（频繁进行CPU调度，所以不需要创建太多线程池，只需要复用即可）：线程数和CPU核数相同 4个
	IO密集型（）：操作数据库、IO等待、阻塞、休眠
			2*CPU核数   8个

Java 锁的机制：（悲观锁、乐观锁、分段锁、重入锁、读写锁、CAS锁、自旋锁、排它锁）
	悲观锁：每次在拿数据时，都会上锁（自带排它锁功能）
		缺点：同时只能让一个连接进行操作
	乐观锁：加一个版本标识，版本控制操作---CAS无锁机制
		因为加了版本号：每次修改数据都会修改版本号，后更新的人就找不到版本号，影响行数为零。
		优点：不会造成线程等待
	如果查询量小：可以使用悲观锁。
	分段锁 ：分段
	重入锁：锁可以传递到下一个方法，可以重复使用同一个锁
		synchronized ReentrantLock 就是重入锁 
	读写锁：保证当做写的操作时候 不允许读，需要等待写入完成，才能读取 （可以做到读写分离） 并不是先写后读的顺序**
		 ReentrantReadWriteLock rwLock=new ReentrantReadWriteLock ()
		  Lock r=rwLock.readLock() //在开始读操作时加入锁
		  r.unlock()////读操作结束时加入
		 Lock w=rwLock.writeLock() //在开始写操作时加入锁
		 w.unlock()//写操作结束时加入
	CAS无锁机制：期望值E，更新变量值V应该相等，则返回更新值N，如果不相等，说明有其他线程已经更新数值N，则当前线程不做任何操作。最后CAS返回当前V的值，
		原子类 AtomicInteger 使用了CAS无锁机制，
	自旋锁： 使用循环 当值更新完成之后，退出循环
	排它锁
	分布式锁
ThreadLocal是什么
	在ThreadLocal中填充的变量属于当前线程，该变量对其他线程而言是隔离的。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。
	对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量但是会进行锁定，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。*****
	ThreadLocal原理
		 ThreadLocal 内部维护了一个 Map ，这个 Map 不是直接使用的 HashMap ，而是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。而我们使用的 get()、set() 方法其实都是调用了这个集合来进行变量的存储
	ThreadLocal怎么用
		在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破层次间的约束。
		2、线程间数据隔离
		3、进行事务操作，用于存储线程事务信息。
		4、数据库连接，Session会话管理。
			如果有1个客户端频繁的使用数据库，那么就需要建立多次链接和关闭，我们的服务器可能会吃不消，怎么办呢？如果有一万个客户端，那么服务器压力更大。
			这时候最好ThreadLocal，因为ThreadLocal在每个线程中对连接会创建一个副本，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能
	ThreadLocal源码分析

	ThreadLocal内存泄漏问题
		1、Thread中有一个map，就是ThreadLocalMap
		2、ThreadLocalMap的key是ThreadLocal，值是我们自己设定的。
		3、ThreadLocal是一个弱引用，当为null时，会被当成垃圾回收
			这时，突然我们ThreadLocal是null了，也就是要被垃圾回收器回收了，但是此时我们的ThreadLocalMap生命周期和Thread的一样，它不会回收，这时候就出现了一个现象。那就是ThreadLocalMap的key没了，但是value还在，这就造成了内存泄漏。
	解决办法：使用完ThreadLocal后，执行remove操作，避免出现内存溢出情况。


