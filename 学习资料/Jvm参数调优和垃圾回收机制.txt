Jvm参数调优和垃圾回收机制；
	JVM 参数调优:
	GC（垃圾回收机制）
		1、需要GC的内存区域：
			jvm 中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于 java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的。
		2.需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。
			（1）引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
			（2）可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。
		4、GC做了什么事：主要做了清理对象，整理内存的工作。Java堆分为新生代和老年代，采用了不同的回收方式。（回收方式即回收算法详见后文）
	垃圾回收机制算法:GC常用算法有：标记-清除算法，标记-压缩算法，复制算法，分代收集算法。
Java内存结构：
	jvm如何判断对象存活：
		引用计数法：
		根搜索算法（GCROOTS主要）：判断对象是否可达需要对象和GCRoot有依赖关系，如果对象没有和GCRoots没有任何引用的情况下
		这是GC就认为该对象为不可达对象。
			GCRoots对象包括：
				（1）虚拟机栈：（栈帧中的局部变量区，也叫做局部变量表）
				（2）方法区中的类静态属性引用的变量
				（3）方法区中常量引用对象
				（4）本地方法中JNI(native方法)引用的对象
Java内存结构和Java内存模型区别:
	Java内存结构:Jvm虚拟机储存空间
	Java内存模型：是线程可见性
class 首先通过类加载器，类加载器再把class 分配到对应的Jvm内存空间
	jvm 内存空间：
		1.方法区：1.8取消
			什么是方法区：方法区也叫永久区、static 关键词修饰、 final 常量信息
				运行时常量池：class文件中除了有类的版本、字段、方法接口等描述信息外
			什么时候初始化：class文件被类加载器加载时，方法区就会被初始化
			调优问题：web开发中，常量定义太多好不好？
				不好，因为常量存放在永久区里面，垃圾回收机制不会经常回收方法区，但是Full Gc也会去回收
				而且常量所有线程也会共享，容易造成线程安全问题
		2.Java 堆
			什么是Java堆（作用）：创建对象、数组 存放在堆内存中。参数调优主要针对java堆，堆内存中所有线程都会共享。
				堆内存分为新生代和老年代
					新生代：存放刚刚创建的对象。
						新生代分为eden区、S0区、S1区
						S0区和S1区大小相同：目的是垃圾回收机制复制算法。
							eden区：存放刚创建的对象。
							From Survivor（s0区域）：存放频繁调用在eden区的对象，就会转移到S0或S1区
							To Survivor（s1区域）：存放频繁调用在eden区的对象，就会转移到S0或S1区
					老年代：存放经常被引用的对象
					jvm 默认新生代与老年代比例为1:2
				目的：垃圾回收机制
				垃圾回收机制主要回收经常新生代，老年代回收次数较少。
		3.Java 栈：
			作用：存放基本数据类型，局部变量，栈代码执行完毕，自动释放其内存，
				栈内存是每个线程私有的，所以栈内存不会产生线程安全问题。类的方法也是存放在栈中。
		4.本地方法栈
			作用：Java语言和调用外部语言，主要使用native调用C语言的（CAS无锁机制）：使用JNI调用C代码。，AtomicInteger原子类底层就是使用native 调用外部语言实现。
		5.PC寄存器：
			作用：每个线程私有线程间不会共享，操作指针，计算变量的指令。
		6.执行引擎：
			作用：主要用来执行class字节码文件。
Jvm常用参数：
	-Xms 堆初始值 
	-Xmx 堆最大可用值
	-Xmn 新生代最大可用值:一般为堆大小的1/3或者1/4
-XX:SurvivorRatio:设置新生代中eden空间和from/to空间的比例
	-XX:SurvivorRatio=eden/from=eden/to
-XX:NewRatio:设置老年代和新生代比例
	-XX:NewRatio=老年代/新生代
Jvm参数调优：
	参数调优方向：
		1.堆初始值与堆内存最大值保持一致
		2.减少GC回收次数
堆内存溢出：java.lang.OutOfMemoryError 内存溢出
	解决办法：设置堆内存大小  -Xmx9m 而且 -Xms800m -Xmx800m 最好设置一样大小，可以有效降低垃圾回收次数
	Tomcat内存溢出在catalina.sh 修改JVM堆内存大小
	JAVA_OPTS="-server -Xms800m -Xmx800m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:MaxNewSize=512m"
栈内存溢出：
	在方法中递归进行调用，而不是循环调用方法。
	解决方法：设置最大调用深度 -Xss5m
垃圾回收机制
	什么是垃圾回收机制？（作用）
		不定时清理堆内存中不可达对象。(不可达：没有经常使用)
	作用：不定时回收堆内存空间资源。
	注意：垃圾回收机制和最大内存-Xmx 没有关系 和初始内存有关系 -Xms
	垃圾回收机制需要经常去老年代回收垃圾么？
		不需要，垃圾回收机制主要回收新生代资源。
	垃圾回收机制调优：
		1.在Web系统中，尽量减少常量信息。
		2.尽量减少垃圾回收机制的次数。
			堆初始值与堆内存最大值保持一致 （减少垃圾回收机制次数）
			提升堆内存初始值大小（初始值越小，垃圾回收机制次数越多）
		3.设置新生代与老年代回收比例：新生代回收次数比老年代多，（尽量减少老年代的回收次数，主要回收新生代）
			一般设置 1:3 或者 1：4
			jvm参数调优,怎样让垃圾回收机制经常去新生代进行回收？
		结论：
			1.堆初始内存越大，吞吐量越高。
			2.垃圾回收机制次数和最大堆内存-Xmx 没有关系 和初始堆内存有关系 -Xms，并且堆内存扩大前后吞吐量不变。 核心是堆内存初始值大小。
System.gc() 手动GC回收
finalize() 方法是Object类中的方法
	作用是：GC回收垃圾前调用的方法，但并不会100%执行（可以把对象设置为null，保证执行）
	一般经过两次标记：第一次经过标记的对象，如果重写了finalize()方法，则会将其放入F-Query队列中，否则，GC直接将对象加入“即将回收”的集合
	在第二次标记之前，F-Query队列中的对象会逐个执行finalize()方法，但是不保证所有的finalize() 都能被执行；
	第二次经过标记的对象
垃圾回收机制面试题：内存溢出和内存泄露区别？****************
	内存溢出：是在申请空间时，超出了最大堆内存空间。  例如：项目启动需要4g内存，当前服务器支持3g
	内存泄露：使用过的内存空间没有被及时释放，长时间占用内存，最终导致内存空间不足，而出现的内存溢出
	对象已经没有被应用程序使用，但是垃圾回收机制无法清除它们，因为它们还在被引用着。
	项目定义了很多静态变量，静态变量会占用很多资源，因为GC不会回收它们。而对象没有被引用，就会报内存泄露。
		内存溢出：可以通过修改JVM内存大小来解决
		内存泄露：可以通过修改最大深度 -Xss5m来解决 减少静态关键字修饰的变量 数据库连接和IO连接要尽量关闭 单例模式有可能也会导致内存泄露
(GC)垃圾回收机制算法：
	1.引用计数法
		原理：每个堆内存的对象默认只有15次机会，GC查看堆内存对象如果对象被引用加一，当对象不可达（不被引用）时减一，为0时，GC直接回收掉。
		优点：引用计数器执行速度很快，交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利。
		缺点：无法检测循环引用：如父对象有一个子对象的引用，子对象又引用父对象。这样就导致它们的引用计数永远不可能为0，而且加减次数过多非常浪费内存。（不常用）
	2.复制算法----只用于新生代*
		用于新生代S0和S1区（S0区和S1区大小是相等的）
		原理：该算法将内存平均分成两部分（S0和S1），然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。
		优点：具有连续性，不会产生碎片化
	3.标记清除算法（不常用）------用于老年代
		原理：为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作。
		优点：最大的优点是，标记—清除算法中每个活着的对象的引用只需要找到一个即可，找到一个就可以判断它为活的。此外，更重要的是，这个算法并不移动对象的位置。
		缺点：它的缺点就是效率比较低（递归与全堆对象遍历）。每个活着的对象都要在标记阶段遍历一遍；所有对象都要在清除阶段扫描一遍，因此算法复杂度较高。没有移动对象，导致可能出现很多碎片空间无法利用的情况。
	4.标记压缩算法---------用于老年代把标记为清除的对象放在一起清理
		用于老年代
		原理：标记-压缩法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。
		优点：该算法不会像标记-清除算法那样产生大量的碎片空间。
		缺点：如果存活的对象过多，整理阶段将会执行较多复制操作，导致算法效率降低。
	5.分代算法----jvm堆内存分为新生代和老年代
		作用：让老年代垃圾回收次数降低，提高新生代的垃圾回收次数
		原理：现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。
		具体过程：新生代(Young)分为Eden区，From区与To区。
垃圾回收机制如果经常执行为什么会降低程序效率？
	垃圾回收机制执行时会导致其他线程会短时间停顿。停顿避免创建新的新生代对象，避免有新垃圾产生。
总结：
	根据GC的工作原理，我们可以通过一些技巧和方式，让GC运行更加有效率，更加符合应用程序的要求。一些关于程序设计的几点建议： 
	1.最基本的建议就是尽早释放无用对象的引用。大多数程序员在使用临时变量的时候，都是让引用变量在退出活动域（scope）后，自动设置为 null.我们在使用这种方式时候，必须特别注意一些复杂的对象图，例如数组，队列，树，图等，这些对象之间有相互引用关系较为复杂。对于这类对象，GC 回收它们一般效率较低。如果程序允许，尽早将不用的引用对象赋为null.这样可以加速GC的工作。 
	2.尽量少用finalize函数。finalize函数是Java提供给程序员一个释放对象或资源的机会。但是，它会加大GC的工作量，因此尽量少采用finalize方式回收资源。 
	3.如果需要使用经常使用的图片，可以使用soft应用类型。它可以尽可能将图片保存在内存中，供程序调用，而不引起OutOfMemory. 
	4.注意集合数据类型，包括数组，树，图，链表等数据结构，这些数据结构对GC来说，回收更为复杂。另外，注意一些全局的变量，以及一些静态变量。这些变量往往容易引起悬挂对象（dangling reference），造成内存浪费。 
	5.当程序有一定的等待时间，程序员可以手动执行System.gc（），通知GC运行，但是Java语言规范并不保证GC一定会执行。使用增量式GC可以缩短Java程序的暂停时间。

Minor GC
从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。这一定义既清晰又易于理解。但是，当发生Minor GC事件的时候，有一些有趣的地方需要注意到：

	当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以分配率越高，越频繁执行 Minor GC。
	内存池被填满的时候，其中的内容全部会被复制，指针会从0开始跟踪空闲内存。Eden 和 Survivor 区进行了标记和复制操作，取代了经典的标记、扫描、压缩、清理操作。所以 Eden 和 Survivor 区不存在内存碎片。写指针总是停留在所使用内存池的顶部。
	执行 Minor GC 操作时，不会影响到永久代。从永久代到年轻代的引用被当成 GC roots，从年轻代到永久代的引用在标记阶段被直接忽略掉。
	质疑常规的认知，所有的 Minor GC 都会触发“全世界的暂停（stop-the-world）”，停止应用程序的线程。对于大部分应用程序，停顿导致的延迟都是可以忽略不计的。其中的真相就 是，大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。如果正好相反，Eden 区大部分新生对象不符合 GC 条件，Minor GC 执行时暂停的时间将会长很多。
	所以 Minor GC 的情况就相当清楚了——每次 Minor GC 会清理年轻代的内存。

Major GC vs Full GC
	大家应该注意到，目前，这些术语无论是在 JVM 规范还是在垃圾收集研究论文中都没有正式的定义。但是我们一看就知道这些在我们已经知道的基础之上做出的定义是正确的，Minor GC 清理年轻带内存应该被设计得简单：

	Major GC 是清理永久代。
	Full GC 是清理整个堆空间—包括年轻代和永久代。

垃圾收集器：
	什么是垃圾收集器:
		1.串行收集器（Serial收集器）：串行收集器是最古老，最稳定，而且效率最高的收集器，可能会产生较长时间的停顿，只使用一个线程进行回收。新生代、老年代使用串行回收；新生代复制算法、老年代使用标记-压缩算法，垃圾收集的过程中会Stop the world （服务暂停）。
			特点：Cpu利用率高，停顿时间即用户等待时间较长。
			适用场景：小型应用。
			通过JVM参数：-XX：+UserSerialGC 调用串行收集器。*****
		2.并行收集器（ParNew收集器）：是串行收集器（Serial收集器）的多线程版本。新生代并行，老年代串行（因为新生代回收次数较多）;新生代使用复制算法、老年代使用标记压缩算法
		多线程并行收集垃圾，效率高，适合于对吞吐量有要求的系统。回收时会停止系统，但时间较短。
		-XX:+UseParNewGC //使用ParNew收集器
		-XX:ParallelGCThreads=20 //设置ParNew收集器的垃圾回收并行线程数
		3.Parallel 收集器：是类似ParNew收集器， 采用多线程来扫描并压缩堆，Parallel 收集器更加关注系统的吞吐量
			特点：停顿时间短，回收效率高，对吞吐量要求高。
			适用场景：大型应用、科学计算，大规模数据采集等。
			-XX:+UseParNewGC
		4.Cms 收集器：采用标记-清除算法实现，使用多线程的方法去扫描堆，对扫描到未使用的对象进行回收。
				（1）初始标记
				（2）并发标记
				（3）并发预处理
				（4）重新标记
				（5）并发清除
				（6）并发重置
			特点：响应时间优先，减少垃圾回收停顿时间
			适用场景：大型服务器。
			优点：并发收集、停顿时间少。
			缺点：产生大量空间碎片，并发阶段会降低吞吐量
			-XX:+UseConcMarkSweepGC //使用CMS收集器
		5.G1收集器：
			在G1中，堆被划分成多个连续的区域。采用G1算法进行回收，吸收了CMS收集器的特点
			特点：支持很大的堆，高吞吐量
				---支持多CPU和垃圾回收线程
				---在主线程暂停的情况下，使用并行收集
				---在主线程运行的情况下，使用并发收集
				并行和并发的区别？
					并行是指多个处理器或者是多核处理器同时处理不同的任务
					并发是指在一个处理器上执行不同的任务
				实现目标：可配置在N毫秒内最多只占用M毫秒的时间进行垃圾回收
				-XX:+UseG1GC //使用G1收集器
吞吐量：每秒的响应



